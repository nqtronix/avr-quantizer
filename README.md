<h1 align="center" style="font-weight: bold; margin-top: 20px; margin-bottom: 20px;">avr-quantizer</h1>

<h4 align="center">An arbitrary value binning quantizer designed for AVR MCUs.</h4>

<p align="center">
	<a href="#changelog"><img src="https://img.shields.io/github/release-pre/nqtronix/avr-quantizer.svg" alt="release: NA"></a>
    <a href="#about"><img src="https://img.shields.io/badge/language-C_(GCC_5.4.0)-blue.svg" alt="language: C GCC (5.4.0)"></a>
    <a href="#about"><img src="https://img.shields.io/badge/platform-AVR8-blue.svg" alt="platform: AVR8"></a>
	<a href="#about"><img src="https://img.shields.io/badge/status-maintained-green.svg" alt="status: maintained"></a>
	<a href="https://github.com/nqtronix/avr-quantizer/issues"><img src="https://img.shields.io/github/issues/nqtronix/avr-quantizer.svg" alt="issues: NA"></a>
	<a href="#license"><img src="https://img.shields.io/github/license/nqtronix/avr-quantizer.svg" alt="license: NA"></a>
</p>


## Introduction
Generating arbitrary values from a small range of input values is easy with LUTs (look up tables). The reverse operation, condensing a large set of values into a small range, is typically either computation intensive (linear search through all values) or memory intensive (requires a LUT with 1000s of entries).

**avr-quantizer** converts arbitrary values into a compact range (0..n) efficently with neither drawback. The value ranges assigned to each output ("binning") is fully user defined and semi-automatically generated by the included excel file. Possible applications include identifying resistor values (E-series) or assigning the nearest octave in audio processing.